git <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Syllable Labeling System</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@300;400;500;700&family=Sarabun:wght@300;400;500;700&family=Prompt:wght@300;400;500;700&family=Kanit:wght@300;400;500;700&family=Noto+Sans:wght@300;400;500;700&family=Tahoma&family=Arial+Unicode+MS&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables for theming */
        :root {
            /* Light mode variables */
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --header-bg: white;
            --header-text: #333;
            --panel-bg: white;
            --panel-text: #333;
            --button-bg: #667eea;
            --button-text: white;
            --button-secondary-bg: #48bb78;
            --input-bg: white;
            --input-border: #e0e0e0;
            --card-bg: white;
            --card-bg-normal: white;
            --card-bg-debug: white;
            --syllable-display-bg-debug: #f8f9fa;
            --debug-dots-opacity: 0;
            --label-font-size: 12px;
            --card-border: #e0e0e0;
            --card-selected-bg: #f0fdf4;
            --card-selected-border: #48bb78;
            --badge-valid-bg: #d4edda;
            --badge-valid-text: #155724;
            --badge-invalid-bg: #f8d7da;
            --badge-invalid-text: #721c24;
            --tag-bg: #e0e7ff;
            --tag-text: #3730a3;
            --modal-bg: white;
            --shadow-color: rgba(0,0,0,0.1);

            /* Syllable visualization colors */
            --syllable-indicator-open-color: #000;
            --syllable-indicator-closed-color: #333;
            --syllable-indicator-open-bg: transparent;
            --syllable-indicator-closed-bg: #333;
            --syllable-label-bg: rgba(255,255,255,0.8);
            --syllable-label-text: #666;
            --debug-dot-bg: #333;
            --debug-dot-border: #666;
            --debug-line-bg: #333;
            --debug-color-red: #e74c3c;
            --debug-color-blue: #007bff;
            --debug-color-green: #28a745;
            --debug-color-orange: #fd7e14;
            --debug-color-purple: #9b59b6;
            --debug-color-dark: #333;
            --accent-pink: #ff1493;
            --arrow-color: #000000;
            --thai-text-color: #333;
        }

        /* Dark mode variables */
        [data-theme="dark"] {
            --bg-gradient: linear-gradient(135deg, #1a1b2e 0%, #16213e 100%);
            --header-bg: #1e2a3a;
            --header-text: white;
            --panel-bg: #1e2a3a;
            --panel-text: white;
            --button-bg: #000000;
            --button-text: white;
            --button-secondary-bg: var(--accent-pink);
            --input-bg: #2a3441;
            --input-border: #4f5b69;
            --card-bg: #2a3441;
            --card-bg-normal: #2a3441;
            --card-bg-debug: #2a3441;
            --syllable-display-bg-debug: transparent;
            --debug-dots-opacity: 0;
            --card-border: #4f5b69;
            --card-selected-bg: color-mix(in srgb, var(--accent-pink) 10%, transparent);
            --card-selected-border: var(--accent-pink);
            --badge-valid-bg: color-mix(in srgb, var(--accent-pink) 20%, transparent);
            --badge-valid-text: var(--accent-pink);
            --badge-invalid-bg: #4c1e1e;
            --badge-invalid-text: #f5a3a3;
            --tag-bg: #1e2a3a;
            --tag-text: #a3b3d4;
            --modal-bg: #1e2a3a;
            --shadow-color: rgba(0,0,0,0.3);

            /* Dark mode syllable visualization colors */
            --syllable-indicator-open-color: #fff;
            --syllable-indicator-closed-color: #ddd;
            --syllable-indicator-open-bg: transparent;
            --syllable-indicator-closed-bg: #ddd;
            --syllable-label-bg: rgba(30,42,58,0.9);
            --syllable-label-text: #ddd;
            --debug-dot-bg: #ddd;
            --debug-dot-border: #999;
            --debug-line-bg: #ddd;
            --debug-color-red: #ff6b6b;
            --debug-color-blue: #4dabf7;
            --debug-color-green: #51cf66;
            --debug-color-orange: #ff8cc8;
            --debug-color-purple: #d0bfff;
            --debug-color-dark: #fff;
            --accent-pink: #ff1493;
            --arrow-color: #ff1493;
            --thai-text-color: #fff;
        }

        /* Dark mode global text color */
        [data-theme="dark"] * {
            color: white;
        }

        /* Keep input text readable in dark mode */
        [data-theme="dark"] input,
        [data-theme="dark"] select,
        [data-theme="dark"] textarea {
            color: #fff;
            background: var(--input-bg);
            border-color: var(--input-border);
        }

        /* Font families for Thai text */
        .thai-noto { font-family: 'Noto Sans Thai', 'Sarabun', 'Prompt', 'Kanit', 'Tahoma', 'Arial Unicode MS', 'Segoe UI', sans-serif; }
        .thai-sarabun { font-family: 'Sarabun', 'Noto Sans Thai', 'Prompt', 'Kanit', 'Tahoma', 'Arial Unicode MS', sans-serif; }
        .thai-prompt { font-family: 'Prompt', 'Noto Sans Thai', 'Sarabun', 'Kanit', 'Tahoma', 'Arial Unicode MS', sans-serif; }
        .thai-kanit { font-family: 'Kanit', 'Noto Sans Thai', 'Sarabun', 'Prompt', 'Tahoma', 'Arial Unicode MS', sans-serif; }

        /* Special class for pattern display with English letters + Thai tone marks */
        .pattern-with-tones {
            font-family: 'Times New Roman', 'Courier New', monospace !important;
            font-size: inherit !important;
            line-height: 1.2 !important;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: var(--header-bg);
            color: var(--header-text);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px var(--shadow-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: var(--header-text);
            margin-bottom: 10px;
        }

        .theme-toggle {
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .stats {
            display: flex;
            gap: 20px;
            color: var(--panel-text);
            font-size: 14px;
        }

        .main-panel {
            background: var(--panel-bg);
            color: var(--panel-text);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px var(--shadow-color);
        }

        .input-section {
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 2px solid #f0f0f0;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .thai-input {
            flex: 1;
            padding: 12px;
            font-size: 24px;
            /* font-family removed - will be set by JavaScript via CSS classes */
            border: 2px solid var(--input-border);
            border-radius: 8px;
            text-align: center;
            background: var(--input-bg);
            color: var(--panel-text);
        }

        .thai-input:focus {
            outline: none;
            border-color: var(--button-bg);
        }

        .btn {
            padding: 12px 24px;
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            opacity: 0.8;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--button-secondary-bg);
        }

        .btn-secondary:hover {
            opacity: 0.8;
        }

        .word-display {
            text-align: center;
            margin-bottom: 40px;
        }

        .word-display h2 {
            font-size: 72px;
            /* font-family removed - will be set by JavaScript via CSS classes */
            color: var(--thai-text-color);
            margin-bottom: 10px;
        }

        .word-info {
            color: var(--panel-text);
            font-size: 14px;
        }

        .interpretations-container {
            display: grid;
            gap: 20px;
        }

        /* MODIFIED: New styles for validation cards instead of selection cards */
        .interpretation-validation-card {
            border: 2px solid var(--card-border);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
            position: relative;
            background: var(--card-bg-debug);
        }

        .validity-dropdown {
            padding: 5px 10px;
            border-radius: 6px;
            border: 1px solid var(--input-border);
            background: var(--input-bg);
            color: var(--input-text);
            font-size: 14px;
        }

        .validity-dropdown option[value="valid"] {
            color: #4CAF50;
        }

        .validity-dropdown option[value="invalid"] {
            color: #f44336;
        }

        .validity-dropdown option[value="synonymous"] {
            color: #2196F3;
        }

        .invalid-components {
            margin-top: 15px;
            padding: 15px;
            background: var(--panel-bg);
            border-radius: 8px;
        }

        .invalid-components h4 {
            margin-bottom: 10px;
            color: var(--panel-text);
        }

        .component-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 10px;
        }

        .component-checkboxes label {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--panel-text);
        }

        .invalid-reason {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid var(--input-border);
            background: var(--input-bg);
            color: var(--input-text);
        }

        .synonymous-selector {
            margin-top: 15px;
            padding: 10px;
            background: var(--panel-bg);
            border-radius: 8px;
        }

        .validation-progress {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--panel-bg);
            border-radius: 8px;
        }

        .validation-progress h3 {
            color: var(--panel-text);
            margin: 0;
        }

        .validation-progress span {
            color: var(--button-bg);
            font-weight: bold;
        }

        .interpretation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .interpretation-id {
            font-weight: bold;
            color: #667eea;
        }

        .validation-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            position: relative;
        }

        .validation-valid {
            background: var(--badge-valid-bg);
            color: var(--badge-valid-text);
        }

        .validation-invalid {
            background: var(--badge-invalid-bg);
            color: var(--badge-invalid-text);
        }

        /* Tooltip for validation issues */
        .validation-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            margin-bottom: 5px;
        }

        .validation-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: #333;
        }

        .validation-badge:hover .validation-tooltip {
            opacity: 1;
        }

        .syllable-display {
            background: var(--syllable-display-bg-debug);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .reading-order {
            position: relative;
            width: 400px;
            height: 160px;
            margin: 15px auto;
        }

        .reading-component {
            text-align: center;
        }

        .component-char {
            font-size: 36px;
            /* font-family removed - will be set by JavaScript via CSS classes */
            color: var(--thai-text-color);
            line-height: 1.2;
            display: inline-block;
            text-align: center;
            /* Force Unicode-capable font for Thai characters */
            unicode-bidi: embed;
            direction: ltr;
        }

        .component-type {
            font-size: 12px;
            color: var(--panel-text);
            margin-top: 5px;
        }

        .pattern-display {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 6px;
            font-family: 'Microsoft Sans Serif' !important;
            font-size: 18px !important;
            color: #4a5568;
        }

        .tags-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }

        .tag {
            display: inline-block;
            padding: 4px 8px;
            margin: 2px;
            background: var(--tag-bg);
            color: var(--tag-text);
            border-radius: 4px;
            font-size: 12px;
        }

        .custom-interpretation-section {
            margin-top: 30px;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 2px dashed var(--card-border);
        }

        .custom-interpretation-section h3 {
            margin-bottom: 15px;
            color: var(--header-text);
        }

        .custom-form {
            display: grid;
            gap: 15px;
        }

        .form-group {
            display: grid;
            grid-template-columns: 120px 1fr;
            align-items: center;
            gap: 10px;
        }

        .form-label {
            font-weight: bold;
            color: var(--panel-text);
        }

        .form-input {
            padding: 8px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background: var(--input-bg);
            color: var(--panel-text);
            /* font-family removed - will be set by JavaScript via CSS classes */
            font-size: 18px;
        }

        .notes-section {
            margin-top: 20px;
        }

        .notes-textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--input-border);
            background: var(--input-bg);
            color: var(--panel-text);
            border-radius: 6px;
            resize: vertical;
            min-height: 60px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .batch-panel {
            position: static;
            width: 100%;
            background: var(--panel-bg);
            color: var(--panel-text);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px var(--shadow-color);
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .batch-panel h3 {
            margin-bottom: 15px;
            color: var(--panel-text);
        }

        .word-queue {
            max-height: 400px;
            overflow-y: auto;
        }

        .queue-item {
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .queue-item:hover {
            background: #f8f9fa;
        }

        .queue-item.current {
            background: #e0e7ff;
            border-color: #667eea;
        }

        .queue-item.labeled {
            background: #d4edda;
            border-color: #48bb78;
        }

        .queue-word {
            /* font-family removed - will be set by JavaScript via CSS classes */
            font-size: 18px;
        }

        .queue-status {
            font-size: 12px;
            color: var(--panel-text);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }

        .help-section {
            margin-top: 10px;
            padding: 10px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            font-size: 14px;
            color: var(--panel-text);
        }

        .font-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .font-controls label {
            font-weight: 500;
            color: var(--panel-text);
            font-size: 14px;
        }

        .font-controls select,
        .font-controls input[type="range"] {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 4px;
            padding: 4px 8px;
            color: var(--panel-text);
        }

        .font-controls input[type="range"] {
            width: 80px;
        }

        .font-size-display {
            font-size: 12px;
            color: var(--panel-text);
            min-width: 35px;
        }

        @media (max-width: 768px) {
            .batch-panel {
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>Thai Syllable Labeling System</h1>
                <div class="stats">
                    <span>Session: <strong id="sessionId">New Session</strong></span>
                    <span>Labels: <strong id="labelCount">0</strong></span>
                    <span>Custom: <strong id="customCount">0</strong></span>
                    <span>Words: <strong id="wordCount">0</strong></span>
                </div>
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <button class="theme-toggle" onclick="toggleTheme()">ðŸŒ™ Dark Mode</button>
                <button class="btn" onclick="restartServer()" style="padding: 8px 16px; font-size: 14px;">ðŸ”„ Restart Server</button>
            </div>
        </div>

        <div class="batch-panel">
            <h3>Word Queue</h3>
            <div class="input-group">
                <textarea id="batchInput" placeholder="Enter words (one per line)" style="width: 100%; height: 80px; padding: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--panel-text);"></textarea>
            </div>
            <button class="btn btn-secondary" onclick="loadBatch()" style="width: 100%; margin-bottom: 15px;">Load Batch</button>
            <div class="word-queue" id="wordQueue"></div>
        </div>

        <div class="main-panel">
            <div class="input-section">
                <div class="input-group">
                    <input type="text" id="wordInput" class="thai-input" placeholder="Enter Thai word...">
                    <button class="btn" onclick="analyzeWord()">Analyze</button>
                </div>
                <div class="help-section">
                    Enter a single Thai syllable to generate all possible interpretations.
                    Select the correct interpretation or add a custom one if the system missed it.
                </div>
            </div>

            <div class="font-controls">
                <label for="fontSelect">Thai Font:</label>
                <select id="fontSelect" onchange="changeThaiFontFamily()">
                    <option value="thai-noto">Noto Sans Thai</option>
                    <option value="thai-sarabun" selected>Sarabun</option>
                    <option value="thai-prompt">Prompt</option>
                    <option value="thai-kanit">Kanit</option>
                </select>

                <label for="fontSizeSlider">Size:</label>
                <input type="range" id="fontSizeSlider" min="12" max="48" value="24" onchange="changeFontSize()">
                <span id="fontSizeDisplay" class="font-size-display">24px</span>

                <label for="fontWeightSelect">Weight:</label>
                <select id="fontWeightSelect" onchange="changeFontWeight()">
                    <option value="300">Light</option>
                    <option value="400">Normal</option>
                    <option value="500">Medium</option>
                    <option value="700">Bold</option>
                </select>

                <div style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
                    <button onclick="toggleTweaksPanel()" style="font-size: 11px; padding: 8px 12px; background: var(--button-bg); color: var(--button-text); border: 1px solid var(--input-border); border-radius: 4px; cursor: pointer;">Tweaks</button>
                    <label for="debugToggle" style="font-size: 12px;">Debug:</label>
                    <input type="checkbox" id="debugToggle" onchange="toggleDebugMode()" style="transform: scale(1.2);">
                </div>
            </div>

            <!-- Interpretation View Tweaks Panel -->
            <div id="tweaksPanel" style="display: none; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 8px; padding: 15px; margin: 10px 0; box-shadow: 0 2px 4px var(--shadow-color);">
                <h3 style="margin: 0 0 15px 0; font-size: 14px; color: var(--header-text);">Interpretation View Tweaks</h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 12px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Triangle Height:</label>
                        <input type="range" id="triangleHeightSlider" min="30" max="120" value="40" onchange="updateTriangleHeight()" style="width: 100%;">
                        <span id="triangleHeightDisplay">40px</span>
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Base Angle:</label>
                        <input type="range" id="baseAngleSlider" min="15" max="45" value="25" onchange="updateBaseAngle()" style="width: 100%;">
                        <span id="baseAngleDisplay">25Â°</span>
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Arrowhead Width:</label>
                        <input type="range" id="arrowWidthSlider" min="4" max="20" value="8" onchange="updateArrowheadSize()" style="width: 100%;">
                        <span id="arrowWidthDisplay">8px</span>
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Arrowhead Height:</label>
                        <input type="range" id="arrowHeightSlider" min="3" max="15" value="6" onchange="updateArrowheadSize()" style="width: 100%;">
                        <span id="arrowHeightDisplay">6px</span>
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Arrow Stroke Width:</label>
                        <input type="range" id="arrowStrokeSlider" min="1" max="5" value="2" onchange="updateArrowStroke()" style="width: 100%;">
                        <span id="arrowStrokeDisplay">2px</span>
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Label Font Size:</label>
                        <input type="range" id="labelFontSizeSlider" min="8" max="16" value="12" onchange="updateLabelFontSize()" style="width: 100%;">
                        <span id="labelFontSizeDisplay">12px</span>
                    </div>

                    <div style="display: flex; align-items: end;">
                        <button onclick="resetTweaksToDefaults()" style="background: #000; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px;">Reset to Defaults</button>
                    </div>
                </div>
            </div>

            <div id="analysisSection" style="display: none;">
                <div class="word-display">
                    <h2 id="currentWord"></h2>
                    <div class="word-info">
                        <span id="interpretationCount"></span> possible interpretations
                    </div>
                </div>

                <div class="interpretations-container" id="interpretationsContainer"></div>

                <div class="custom-interpretation-section">
                    <h3>Custom Interpretation (if system missed it)</h3>
                    <div class="custom-form">
                        <div class="form-group">
                            <label class="form-label">Foundation:</label>
                            <input type="text" id="customFoundation" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Vowel:</label>
                            <input type="text" id="customVowel" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Final:</label>
                            <input type="text" id="customFinal" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Pattern:</label>
                            <input type="text" id="customPattern" class="form-input" placeholder="e.g., xà¸², à¹€xf">
                        </div>
                    </div>
                </div>

                <div class="notes-section">
                    <label style="font-weight: bold; color: var(--panel-text); display: block; margin-bottom: 5px;">Notes:</label>
                    <textarea id="labelNotes" class="notes-textarea" placeholder="Add any notes about this labeling decision..."></textarea>
                </div>

                <div class="action-buttons">
                    <button class="btn" onclick="saveLabel()">Save Label</button>
                    <button class="btn btn-secondary" onclick="skipWord()">Skip</button>
                </div>
            </div>
        </div>
    </div>

    <div id="successModal" class="modal">
        <div class="modal-content">
            <h3 style="color: #48bb78; margin-bottom: 15px;">Label Saved!</h3>
            <p id="modalMessage"></p>
            <button class="btn" onclick="closeModal()" style="margin-top: 15px;">Continue</button>
        </div>
    </div>

    <script>
        // State management
        let currentWord = '';
        let currentWordId = null;
        let currentInterpretations = [];
        let selectedInterpretation = null;
        let sessionId = null;
        let wordQueue = [];
        let currentQueueIndex = -1;
        let stats = {
            labels: 0,
            custom: 0,
            words: new Set()
        };


        function initSession() {
            // Create new session or restore existing
            sessionId = localStorage.getItem('labeling_session_id');
            if (!sessionId) {
                sessionId = 'session_' + Date.now();
                localStorage.setItem('labeling_session_id', sessionId);
            }
            document.getElementById('sessionId').textContent = sessionId.substring(0, 15) + '...';
            updateStats();
        }

        async function analyzeWord(word = null) {
            const inputWord = word || document.getElementById('wordInput').value.trim();
            if (!inputWord) return;

            currentWord = inputWord;
            document.getElementById('currentWord').textContent = currentWord;
            document.getElementById('analysisSection').style.display = 'block';

            try {
                const response = await fetch('http://localhost:5001/api/generate-interpretations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word: inputWord })
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                currentWordId = data.word_id;
                currentInterpretations = data.interpretations || [];

                document.getElementById('interpretationCount').textContent = data.count || currentInterpretations.length;
                renderInterpretations(currentInterpretations);

                // Clear custom form
                document.getElementById('customFoundation').value = '';
                document.getElementById('customVowel').value = '';
                document.getElementById('customFinal').value = '';
                document.getElementById('customPattern').value = '';
                document.getElementById('labelNotes').value = '';

            } catch (error) {
                console.error('Error analyzing word:', error);
                alert('Error analyzing word. Please check the server is running.');
            }
        }

        // MODIFIED: Render interpretations as a validation grid instead of selectable cards
        function renderInterpretations(interpretations) {
            const container = document.getElementById('interpretationsContainer');
            container.innerHTML = '';
            selectedInterpretation = null;

            if (!interpretations || interpretations.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--panel-text);">No interpretations generated. Try a different word.</div>';
                return;
            }

            // Add progress indicator
            const progressDiv = document.createElement('div');
            progressDiv.className = 'validation-progress';
            progressDiv.innerHTML = `
                <h3>Validation Progress: <span id="validationProgress">0/${interpretations.length}</span> interpretations labeled</h3>
            `;
            container.appendChild(progressDiv);

            interpretations.forEach((interp, index) => {
                const card = document.createElement('div');
                card.className = 'interpretation-validation-card';
                card.dataset.interpId = interp.db_id;
                card.dataset.index = index;

                const syllable = interp.syllables[0]; // Single syllable focus

                card.innerHTML = `
                    <div class="interpretation-header">
                        <span class="interpretation-id">Interpretation ${index + 1}</span>
                        <select class="validity-dropdown" id="validity-${index}" onchange="onValidityChange(${index})">
                            <option value="unlabeled">-- Select Status --</option>
                            <option value="valid">Valid</option>
                            <option value="invalid">Invalid</option>
                            <option value="synonymous">Synonymous</option>
                        </select>
                    </div>
                    <div class="syllable-display">
                        <div class="reading-order">
                            ${renderReadingOrder(syllable)}
                        </div>
                    </div>
                    <div class="invalid-components" id="invalid-components-${index}" style="display: none;">
                        <h4>Mark Invalid Components:</h4>
                        <div class="component-checkboxes">
                            <label><input type="checkbox" value="foundation" data-value="${syllable.foundation}"> Foundation${syllable.foundation ? ` (${syllable.foundation})` : ''}</label>
                            <label><input type="checkbox" value="vowel" data-value="${syllable.vowel}"> Vowel${syllable.vowel ? ` (${syllable.vowel})` : ''}</label>
                            <label><input type="checkbox" value="final" data-value="${syllable.final}"> Final${syllable.final ? ` (${syllable.final})` : ''}</label>
                            <label><input type="checkbox" value="pattern" data-value="${syllable.pattern}"> Pattern${syllable.pattern ? ` (${syllable.pattern})` : ''}</label>
                        </div>
                        <input type="text" placeholder="Reason (optional)" class="invalid-reason" id="invalid-reason-${index}">
                    </div>
                    <div class="synonymous-selector" id="synonymous-${index}" style="display: none;">
                        <label>Synonymous with:
                            <select id="synonymous-with-${index}">
                                <option value="">-- Select --</option>
                                ${interpretations.map((other, i) =>
                                    i !== index ? `<option value="${other.db_id}">Interpretation ${i + 1}</option>` : ''
                                ).join('')}
                            </select>
                        </label>
                    </div>
                    <div class="tags-section" id="tags-${index}">
                        <small style="color: #999;">Loading tags...</small>
                    </div>
                `;

                container.appendChild(card);
                loadTagsForInterpretation(syllable, index);
            });

            // Apply font settings to newly created interpretation elements
            applyFontSettings();
        }

        function getFoundationMapping(syllable) {
            const pattern = syllable.pattern || '';
            if (!pattern.includes('x') && !pattern.includes('f')) {
                return ''; // No template variables to map
            }

            let mapping = '<div class="foundation-mapping" style="font-size: 12px; color: var(--panel-text); margin-top: 4px;">';

            // Get foundation characters
            let foundationChars = [];
            if (syllable.foundation) {
                if (typeof syllable.foundation === 'object' && syllable.foundation.consonants) {
                    foundationChars = syllable.foundation.consonants;
                } else if (Array.isArray(syllable.foundation)) {
                    foundationChars = syllable.foundation;
                } else {
                    foundationChars = [syllable.foundation];
                }
            }

            // Get final characters
            let finalChars = [];
            if (syllable.final) {
                if (typeof syllable.final === 'object' && syllable.final.consonants) {
                    finalChars = syllable.final.consonants;
                } else if (Array.isArray(syllable.final)) {
                    finalChars = syllable.final;
                } else {
                    finalChars = [syllable.final];
                }
            }

            // Map x to foundation
            if (pattern.includes('x')) {
                const foundationStr = foundationChars.join('');
                const isCluster = foundationChars.length > 1;
                mapping += `x = ${foundationStr || '?'}${isCluster ? ' (cluster)' : ''} `;
            }

            // Map f to final
            if (pattern.includes('f')) {
                const finalStr = finalChars.join('');
                const isFinalCluster = finalChars.length > 1;
                mapping += `f = ${finalStr || '?'}${isFinalCluster ? ' (cluster)' : ''}`;
            }

            mapping += '</div>';
            return mapping;
        }

        function calculateAngle(x1, y1, x2, y2) {
            // Calculate angle in degrees from horizontal
            const deltaX = x2 - x1;
            const deltaY = y2 - y1;
            const angleRadians = Math.atan2(deltaY, deltaX);
            const angleDegrees = angleRadians * (180 / Math.PI);
            return Math.abs(angleDegrees); // Return absolute angle
        }

        function calculateDynamicPositions(containerId) {
            // Find the reading-order div that contains our elements
            const readingOrderDivs = document.querySelectorAll('.reading-order');
            let container = null;

            // Find the reading-order div that contains our containerId elements
            for (let div of readingOrderDivs) {
                if (div.querySelector(`#foundation-${containerId}`)) {
                    container = div;
                    break;
                }
            }
            const foundationWrapper = document.getElementById(`foundation-wrapper-${containerId}`);
            const finalWrapper = document.getElementById(`final-wrapper-${containerId}`);
            const foundationBox = document.getElementById(`foundation-${containerId}`);
            const finalBox = document.getElementById(`final-${containerId}`);
            const vowelBox = document.getElementById(`vowel-${containerId}`);

            if (!container || !foundationWrapper || !finalWrapper || !foundationBox || !vowelBox) {
                return;
            }

            // Constants for 30-degree triangle
            const TARGET_ANGLE = 30; // degrees
            const VERTICAL_DISTANCE = 100; // pixels from vowel to bottom row

            // Calculate required horizontal distance for 30-degree angle
            // tan(30Â°) = opposite/adjacent = vertical_distance/horizontal_distance
            // horizontal_distance = vertical_distance / tan(30Â°)
            const angleRadians = TARGET_ANGLE * (Math.PI / 180);
            const requiredHorizontalDistance = VERTICAL_DISTANCE / Math.tan(angleRadians);

            console.log(`Required horizontal distance for 30Â°: ${requiredHorizontalDistance.toFixed(1)}px`);

            // Measure text widths (need to position temporarily to get measurements)
            foundationWrapper.style.left = '0px';
            finalWrapper.style.left = '0px';

            // Force layout calculation
            foundationWrapper.offsetWidth;
            finalWrapper.offsetWidth;

            const foundationWidth = foundationBox.offsetWidth;
            const finalWidth = finalBox.offsetWidth;

            console.log(`ðŸ”§ calculateDynamicPositions(${containerId}): Foundation: ${foundationWidth}px, Final: ${finalWidth}px`);

            // Calculate container center
            const containerWidth = container.offsetWidth;
            const centerX = containerWidth / 2;
            console.log(`ðŸ“ Container ${containerId}: width=${containerWidth}px, centerX=${centerX}px`);

            // Calculate positions for symmetric layout using max distance
            // Use the larger of the two required distances to maintain symmetry
            const foundationRightToCenter = requiredHorizontalDistance;
            const finalLeftToCenter = requiredHorizontalDistance;
            const maxDistance = Math.max(foundationRightToCenter, finalLeftToCenter);

            // TEXT POSITIONING MOVED TO positionDotsForContainer (per-interpretation)
            // NOTE: Text uses Microsoft Sans Serif font for vowel patterns with tone marks

            // Update container width - keep default since text is hidden
            const requiredContainerWidth = Math.max(400, containerWidth);
            if (requiredContainerWidth > containerWidth) {
                container.style.width = requiredContainerWidth + 'px';
            }

            console.log(`Naive positioning - text at triangle dots:`, {
                triangleDotsVisible: true,
                textFieldsVisible: true,
                requiredHorizontalDistance: requiredHorizontalDistance.toFixed(1),
                containerWidth: container.offsetWidth
            });

            // Position dots for verification
            positionDotsForContainer(containerId);
        }

        function positionDotsForContainer(containerId) {
            // === PHASE 1: SETUP & VALIDATION ===
            const elements = setupAndValidateElements(containerId);
            if (!elements) return;

            // === PHASE 2: COORDINATE SYSTEM & CONFIG ===
            const config = calculateCoordinateSystemAndConfig(elements.container);
            if (!config) return;

            // === PHASE 3: ELEMENT MEASUREMENT ===
            const dimensions = measureElementDimensions(elements);

            // === PHASE 4: CORE POSITIONING CALCULATIONS ===
            const positions = calculateDotPositions(config, dimensions);

            // === PHASE 5: TEXT POSITIONING ===
            positionTextElements(elements, positions, dimensions, config);

            // === PHASE 5B: LABEL POSITIONING (using pre-measured dimensions) ===
            positionLabelsWithMeasuredDimensions(elements, positions, dimensions, config);

            // === PHASE 6: VISUALIZATION UPDATES ===
            updateVisualizationElements(elements, positions, config, dimensions);

            // === PHASE 7: DEBUG INFORMATION ===
            updateDebugInformation(elements, positions, config, dimensions);

            // === PHASE 8: LAYOUT-DEPENDENT UPDATES (ASYNC) ===
            updateLayoutDependentElements(elements, positions, dimensions, config);
        }

        function setupAndValidateElements(containerId) {
            // Find the reading-order div that contains our elements
            const readingOrderDivs = document.querySelectorAll('.reading-order');
            let container = null;

            for (let div of readingOrderDivs) {
                if (div.querySelector(`#foundation-${containerId}`)) {
                    container = div;
                    break;
                }
            }

            // Get all required DOM elements
            const elements = {
                container,
                foundationWrapper: document.getElementById(`foundation-wrapper-${containerId}`),
                finalWrapper: document.getElementById(`final-wrapper-${containerId}`),
                foundationBox: document.getElementById(`foundation-${containerId}`),
                finalBox: document.getElementById(`final-${containerId}`),
                vowelBox: document.getElementById(`vowel-${containerId}`),

                // Visualization elements
                centerDot: document.getElementById(`center-dot-${containerId}`),
                basePoint: document.getElementById(`base-point-${containerId}`),
                pointVowel: document.getElementById(`point-vowel-${containerId}`),
                pointVowelPurple: document.getElementById(`point-vowel-purple-${containerId}`),
                pointVowelPink: document.getElementById(`point-vowel-pink-${containerId}`),
                pointF1: document.getElementById(`point-f1-${containerId}`),
                pointF2: document.getElementById(`point-f2-${containerId}`),
                redGreenLine: document.getElementById(`red-green-line-${containerId}`),
                redPinkArrow: document.getElementById(`red-pink-arrow-${containerId}`),
                purpleGreenArrow: document.getElementById(`purple-green-arrow-${containerId}`),

                // Debug elements
                leftDistance: document.getElementById(`left-distance-${containerId}`),
                rightDistance: document.getElementById(`right-distance-${containerId}`),
                verticalDistance: document.getElementById(`vertical-distance-${containerId}`),
                horizontalLeftDistance: document.getElementById(`horizontal-left-distance-${containerId}`),
                horizontalRightDistance: document.getElementById(`horizontal-right-distance-${containerId}`),
                foundationBorder: document.getElementById(`foundation-border-${containerId}`),
                vowelBorder: document.getElementById(`vowel-border-${containerId}`),
                finalBorder: document.getElementById(`final-border-${containerId}`),
                closedBorder: document.getElementById(`closed-border-${containerId}`),
                foundationDimensions: document.getElementById(`foundation-dimensions-${containerId}`),
                vowelDimensions: document.getElementById(`vowel-dimensions-${containerId}`),
                finalDimensions: document.getElementById(`final-dimensions-${containerId}`),
                angleText: document.getElementById(`angle-text-${containerId}`),
                angleTextGreen: document.getElementById(`angle-text-green-${containerId}`),
                distanceLabel: document.getElementById(`distance-label-${containerId}`),
                greenDistanceLabel: document.getElementById(`green-distance-label-${containerId}`),
                foundationLabel: document.getElementById(`foundation-label-${containerId}`),
                vowelLabel: document.getElementById(`vowel-label-${containerId}`),
                finalLabel: document.getElementById(`final-label-${containerId}`),
                closedIndicator: document.getElementById(`closed-indicator-${containerId}`)
            };

            // Validate critical elements
            const requiredElements = [
                'container', 'foundationWrapper', 'finalWrapper', 'foundationBox', 'vowelBox',
                'centerDot', 'basePoint', 'pointVowel', 'pointF1', 'pointF2', 'redGreenLine'
            ];

            for (const elementName of requiredElements) {
                if (!elements[elementName]) {
                    console.warn(`Missing required element: ${elementName} for container ${containerId}`);
                    return null;
                }
            }

            return elements;
        }

        function calculateCoordinateSystemAndConfig(container) {
            // Get the cyan syllable-display container (parent of the reading-order container)
            const syllableDisplay = container.parentElement;
            if (!syllableDisplay) return null;

            const syllableDisplayRect = syllableDisplay.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            // Calculate center position of the cyan container relative to the reading-order container
            const cyanCenterX = (syllableDisplayRect.left + syllableDisplayRect.width / 2) - containerRect.left;
            const cyanCenterY = (syllableDisplayRect.top + syllableDisplayRect.height / 2) - containerRect.top;

            // Read configuration from CSS
            const triangle_h = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--triangle-height')) || 70;
            const baseCornerAngle = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--base-angle')) || 25;
            const angleRadians = baseCornerAngle * (Math.PI / 180);
            const triangle_base_pos = cyanCenterY + triangle_h / 2;
            const basePointY = triangle_base_pos;

            return {
                cyanCenterX,
                cyanCenterY,
                triangle_h,
                baseCornerAngle,
                angleRadians,
                basePointY,
                dotmargin: 5
            };
        }

        function measureElementDimensions(elements) {
            // Position text elements temporarily for accurate measurement
            elements.foundationWrapper.style.left = '0px';
            elements.foundationWrapper.style.top = '0px';
            elements.finalWrapper.style.left = '0px';
            elements.finalWrapper.style.top = '0px';
            elements.vowelBox.style.left = '0px';
            elements.vowelBox.style.top = '0px';

            // Force layout recalculation for Thai text elements
            elements.foundationWrapper.offsetWidth;
            elements.finalWrapper.offsetWidth;
            elements.vowelBox.offsetWidth;

            // Get Thai character dimensions only (labels measured during positioning)
            const vowelChar = elements.vowelBox.querySelector('.component-char');

            return {
                foundationWidth: elements.foundationBox.offsetWidth,
                foundationHeight: elements.foundationBox.offsetHeight,
                finalWidth: elements.finalBox.offsetWidth,
                finalHeight: elements.finalBox.offsetHeight,
                vowelWidth: vowelChar.offsetWidth,
                vowelHeight: vowelChar.offsetHeight
            };
        }

        function calculateDotPositions(config, dimensions) {
            const { cyanCenterX, triangle_h, basePointY, angleRadians, dotmargin } = config;
            const { vowelWidth, vowelHeight } = dimensions;

            // Blue dot (vowel center)
            const blueDotX = cyanCenterX;
            const blueDotY_actual = basePointY - triangle_h;

            // Pink/Purple dots (based on vowel dimensions)
            const pinkDotY_actual = blueDotY_actual - vowelHeight / 2;
            const purpleDotY_actual = blueDotY_actual - vowelHeight / 2;
            const pinkDotX = blueDotX - vowelWidth / 2 - dotmargin;
            const purpleDotX = blueDotX + vowelWidth / 2 + dotmargin;

            // Trigonometric offset calculations for consistent angles
            const verticalDistance_to_pink = Math.abs(basePointY - pinkDotY_actual);
            const verticalDistance_to_purple = Math.abs(basePointY - purpleDotY_actual);
            const horizontalOffset_from_pink = verticalDistance_to_pink / Math.tan(angleRadians);
            const horizontalOffset_from_purple = verticalDistance_to_purple / Math.tan(angleRadians);

            // Final corrected dot positions
            const correctedRedDotX = pinkDotX - horizontalOffset_from_pink;
            const correctedGreenDotX = purpleDotX + horizontalOffset_from_purple;

            return {
                blueDotX,
                blueDotY_actual,
                pinkDotX,
                pinkDotY_actual,
                purpleDotX,
                purpleDotY_actual,
                correctedRedDotX,
                correctedGreenDotX,
                horizontalOffset_from_pink,
                horizontalOffset_from_purple,
                verticalDistance_to_pink,
                verticalDistance_to_purple
            };
        }

        function positionTextElements(elements, positions, dimensions, config) {
            const { correctedRedDotX, correctedGreenDotX, blueDotX, blueDotY_actual } = positions;
            const { foundationWidth, foundationHeight, finalWidth, finalHeight, vowelHeight } = dimensions;
            const { basePointY, dotmargin } = config;

            // Check if final exists by looking for actual final text content
            const finalTextContent = elements.finalBox ? elements.finalBox.textContent.trim() : '';
            const hasNoFinal = !elements.finalBox || finalTextContent === '' || finalTextContent === 'âˆ…' || finalTextContent === 'â€”';

            // Foundation: left of red dot
            elements.foundationWrapper.style.left = (correctedRedDotX - foundationWidth - dotmargin) + 'px';
            elements.foundationWrapper.style.top = (basePointY - foundationHeight / 2) + 'px';

            // Final: right of green dot (DEBUG: Conditionally lift green dot only if no final)
            const greenDotY = hasNoFinal ?
                basePointY - (config.triangle_h + (finalHeight / 2)) :  // DEBUG: Lift if no final
                basePointY;  // Normal position if final exists

            elements.finalWrapper.style.left = (correctedGreenDotX + dotmargin) + 'px';
            elements.finalWrapper.style.top = (greenDotY - finalHeight / 2) + 'px';

            // Vowel: centered on blue dot
            elements.vowelBox.style.left = (blueDotX - dimensions.vowelWidth / 2) + 'px';
            elements.vowelBox.style.top = (blueDotY_actual - vowelHeight) + 'px';
        }

        function positionLabelsWithMeasuredDimensions(elements, positions, dimensions, config) {
            // Position labels by: 1) Place temporarily, 2) Measure actual size, 3) Center properly
            const { correctedRedDotX, correctedGreenDotX, blueDotX, blueDotY_actual } = positions;
            const { foundationWidth, foundationHeight, finalWidth, finalHeight, vowelHeight } = dimensions;
            const { basePointY, dotmargin } = config;

            // Foundation label - centered under foundation text
            if (elements.foundationLabel) {
                const foundationCenterX = correctedRedDotX - foundationWidth - dotmargin + (foundationWidth / 2);
                const foundationLabelY = basePointY + foundationHeight / 2 + 5;

                // Step 1: Position at target center (temporarily, may be off-center)
                elements.foundationLabel.style.left = foundationCenterX + 'px';
                elements.foundationLabel.style.top = foundationLabelY + 'px';

                // Step 2: Force layout and measure actual label width after font change
                const actualFoundationLabelWidth = elements.foundationLabel.offsetWidth;

                // Step 3: Re-position using actual measured width for perfect centering
                elements.foundationLabel.style.left = (foundationCenterX - actualFoundationLabelWidth / 2) + 'px';
            }

            // Vowel label - centered under vowel text
            if (elements.vowelLabel) {
                const vowelCenterX = blueDotX;
                const vowelCenterY = blueDotY_actual - vowelHeight / 2;
                const vowelLabelY = vowelCenterY + vowelHeight / 2 + 5;

                // Step 1: Position at target center (temporarily, may be off-center)
                elements.vowelLabel.style.left = vowelCenterX + 'px';
                elements.vowelLabel.style.top = vowelLabelY + 'px';

                // Step 2: Force layout and measure actual label width after font change
                const actualVowelLabelWidth = elements.vowelLabel.offsetWidth;

                // Step 3: Re-position using actual measured width for perfect centering
                elements.vowelLabel.style.left = (vowelCenterX - actualVowelLabelWidth / 2) + 'px';
            }

            // Final label - centered under final text (follows conditional green dot position)
            if (elements.finalLabel) {
                // Check if final exists (same logic as text positioning)
                const finalTextContent = elements.finalBox ? elements.finalBox.textContent.trim() : '';
                const hasNoFinal = !elements.finalBox || finalTextContent === '' || finalTextContent === 'âˆ…' || finalTextContent === 'â€”';

                // Use same conditional green dot calculation as final text positioning
                const greenDotY = hasNoFinal ?
                    basePointY - (config.triangle_h + (finalHeight / 2)) :  // DEBUG: Lift if no final
                    basePointY;  // Normal position if final exists

                const finalCenterX = correctedGreenDotX + dotmargin + (finalWidth / 2);
                const finalLabelY = greenDotY + finalHeight / 2 + 5; // Follow final text position

                // Step 1: Position at target center (temporarily, may be off-center)
                elements.finalLabel.style.left = finalCenterX + 'px';
                elements.finalLabel.style.top = finalLabelY + 'px';

                // Step 2: Force layout and measure actual label width after font change
                const actualFinalLabelWidth = elements.finalLabel.offsetWidth;

                // Step 3: Re-position using actual measured width for perfect centering
                elements.finalLabel.style.left = (finalCenterX - actualFinalLabelWidth / 2) + 'px';
            }

            // Closed indicator - positioned to the right of final textbox (vertical center aligned with green dot)
            if (elements.closedIndicator) {
                // Check if final exists by looking for actual final text content (same logic as text positioning)
                const finalTextContent = elements.finalBox ? elements.finalBox.textContent.trim() : '';
                const hasNoFinal = !elements.finalBox || finalTextContent === '' || finalTextContent === 'âˆ…' || finalTextContent === 'â€”';

                // Use same conditional green dot calculation as text positioning
                const greenDotY = hasNoFinal ?
                    basePointY - (config.triangle_h + (finalHeight / 2)) :  // DEBUG: Lift if no final
                    basePointY;  // Normal position if final exists

                const finalRightEdge = correctedGreenDotX + dotmargin + finalWidth;
                const closedIndicatorX = finalRightEdge + 8; // 8px gap from final text

                // Position temporarily to measure height, then center on green dot
                elements.closedIndicator.style.left = closedIndicatorX + 'px';
                elements.closedIndicator.style.top = '0px'; // Temporary position

                // Measure actual closed indicator height
                const closedIndicatorHeight = elements.closedIndicator.offsetHeight;

                // Center the closed indicator vertically on the green dot position
                const closedIndicatorY = greenDotY - (closedIndicatorHeight / 2);
                elements.closedIndicator.style.top = closedIndicatorY + 'px';
            }
        }


        function updateVisualizationElements(elements, positions, config, dimensions) {
            const { cyanCenterX, basePointY, triangle_h } = config;
            const { correctedRedDotX, correctedGreenDotX, blueDotX, blueDotY_actual, pinkDotX, pinkDotY_actual, purpleDotX, purpleDotY_actual } = positions;
            const { finalWidth, finalHeight } = dimensions;

            // Check if final exists by looking for actual final text content (same logic as text positioning)
            const finalTextContent = elements.finalBox ? elements.finalBox.textContent.trim() : '';
            const hasNoFinal = !elements.finalBox || finalTextContent === '' || finalTextContent === 'âˆ…' || finalTextContent === 'â€”';

            // Position core dots
            elements.centerDot.style.left = (cyanCenterX - 4) + 'px';
            elements.centerDot.style.top = (config.cyanCenterY - 4) + 'px';
            elements.basePoint.style.left = (cyanCenterX - 4) + 'px';
            elements.basePoint.style.top = (basePointY - 4) + 'px';
            elements.pointVowel.style.left = (cyanCenterX - 4) + 'px';
            elements.pointVowel.style.top = (basePointY - triangle_h - 4) + 'px';

            // Position corrected red/green dots
            elements.pointF1.style.left = (correctedRedDotX - 4) + 'px';
            elements.pointF1.style.top = (basePointY - 4) + 'px';
            elements.pointF2.style.left = (correctedGreenDotX - 4) + 'px';
            // Green dot: Conditionally lift only if no final exists (DEBUG)
            const greenDotVisualizationY = hasNoFinal ?
                basePointY - (triangle_h + (finalHeight / 2)) - 4 :  // DEBUG: Lift if no final
                basePointY - 4;  // Normal position if final exists
            elements.pointF2.style.top = greenDotVisualizationY + 'px';

            // Position vowel-based dots
            if (elements.pointVowelPurple) {
                elements.pointVowelPurple.style.left = (purpleDotX - 4) + 'px';
                elements.pointVowelPurple.style.top = (purpleDotY_actual - 4) + 'px';
            }
            if (elements.pointVowelPink) {
                elements.pointVowelPink.style.left = (pinkDotX - 4) + 'px';
                elements.pointVowelPink.style.top = (pinkDotY_actual - 4) + 'px';
            }

            // Update line between red and green dots
            const correctedLineWidth = correctedGreenDotX - correctedRedDotX;
            elements.redGreenLine.style.left = correctedRedDotX + 'px';
            elements.redGreenLine.style.top = (basePointY - 1) + 'px';
            elements.redGreenLine.style.width = correctedLineWidth + 'px';

            // Update arrows
            updateArrows(elements, positions, config, dimensions);
        }

        function updateArrows(elements, positions, config, dimensions) {
            const { correctedRedDotX, correctedGreenDotX, pinkDotX, pinkDotY_actual, purpleDotX, purpleDotY_actual } = positions;
            const { basePointY } = config;
            const { finalWidth, finalHeight } = dimensions;

            // Check if final exists - same logic as other functions
            const finalTextContent = elements.finalBox ? elements.finalBox.textContent.trim() : '';
            const hasNoFinal = !elements.finalBox || finalTextContent === '' || finalTextContent === 'âˆ…' || finalTextContent === 'â€”';

            // Calculate actual green dot Y position (conditional)
            const actualGreenDotY = hasNoFinal ?
                basePointY - (config.triangle_h + (finalHeight / 2)) :  // DEBUG: Lift if no final
                basePointY;  // Normal position if final exists

            // Red to pink arrow
            if (elements.redPinkArrow) {
                const deltaX = pinkDotX - correctedRedDotX;
                const deltaY = pinkDotY_actual - basePointY;
                const arrowLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const arrowAngle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);

                elements.redPinkArrow.style.left = correctedRedDotX + 'px';
                elements.redPinkArrow.style.top = (basePointY - 5) + 'px';
                elements.redPinkArrow.style.width = arrowLength + 'px';
                elements.redPinkArrow.style.height = '10px';
                elements.redPinkArrow.style.transformOrigin = '0 50%';
                elements.redPinkArrow.style.transform = `rotate(${arrowAngle}deg)`;

                const arrowLine = elements.redPinkArrow.querySelector('line');
                if (arrowLine) {
                    arrowLine.setAttribute('x2', arrowLength);
                    arrowLine.setAttribute('y1', '5');
                    arrowLine.setAttribute('y2', '5');
                }
            }

            // Purple to green arrow (using actual green dot position)
            if (elements.purpleGreenArrow) {
                const deltaX_pg = correctedGreenDotX - purpleDotX;
                const deltaY_pg = actualGreenDotY - purpleDotY_actual; // Use conditional green dot Y
                const arrowLength_pg = Math.sqrt(deltaX_pg * deltaX_pg + deltaY_pg * deltaY_pg);
                const arrowAngle_pg = Math.atan2(deltaY_pg, deltaX_pg) * (180 / Math.PI);

                elements.purpleGreenArrow.style.left = purpleDotX + 'px';
                elements.purpleGreenArrow.style.top = (purpleDotY_actual - 5) + 'px';
                elements.purpleGreenArrow.style.width = arrowLength_pg + 'px';
                elements.purpleGreenArrow.style.height = '10px';
                elements.purpleGreenArrow.style.transformOrigin = '0 50%';
                elements.purpleGreenArrow.style.transform = `rotate(${arrowAngle_pg}deg)`;

                const arrowLine_pg = elements.purpleGreenArrow.querySelector('line');
                if (arrowLine_pg) {
                    arrowLine_pg.setAttribute('x2', arrowLength_pg);
                    arrowLine_pg.setAttribute('y1', '5');
                    arrowLine_pg.setAttribute('y2', '5');
                }
            }
        }

        function updateDebugInformation(elements, positions, config, dimensions) {
            const { cyanCenterX, basePointY, dotmargin, baseCornerAngle, angleRadians } = config;
            const { correctedRedDotX, correctedGreenDotX, pinkDotX, pinkDotY_actual, purpleDotX, purpleDotY_actual, horizontalOffset_from_pink, horizontalOffset_from_purple } = positions;

            // Update distance labels
            if (elements.distanceLabel) {
                const distance = Math.abs(correctedRedDotX - cyanCenterX);
                const midX = (cyanCenterX + correctedRedDotX) / 2;
                elements.distanceLabel.style.left = (midX - 25) + 'px';
                elements.distanceLabel.style.top = (basePointY + 10) + 'px';
                elements.distanceLabel.textContent = `${Math.round(distance)}px`;
            }

            if (elements.greenDistanceLabel) {
                const distance_green = Math.abs(correctedGreenDotX - cyanCenterX);
                const midX_green = (cyanCenterX + correctedGreenDotX) / 2;
                elements.greenDistanceLabel.style.left = (midX_green - 25) + 'px';
                elements.greenDistanceLabel.style.top = (basePointY + 10) + 'px';
                elements.greenDistanceLabel.textContent = `${Math.round(distance_green)}px`;
            }

            // Update angle displays
            updateAngleDisplays(elements, positions, config, dimensions);

            // Console logging for debugging
            console.log(`ðŸŽ¯ CONSISTENT ANGLE CALCULATION:
                Pink dot: (${pinkDotX.toFixed(1)}, ${pinkDotY_actual.toFixed(1)})
                Purple dot: (${purpleDotX.toFixed(1)}, ${purpleDotY_actual.toFixed(1)})
                Vertical distance: ${positions.verticalDistance_to_pink.toFixed(1)}px
                Horizontal offset from pink: ${horizontalOffset_from_pink.toFixed(1)}px
                Horizontal offset from purple: ${horizontalOffset_from_purple.toFixed(1)}px
                Red dot X: ${correctedRedDotX.toFixed(1)}
                Green dot X: ${correctedGreenDotX.toFixed(1)}
                Target angle: ${(angleRadians * 180 / Math.PI).toFixed(1)}Â°`);

            console.log(`ðŸ”´ Red dot CORRECTED at X=${correctedRedDotX} (center=${cyanCenterX} - offset=${horizontalOffset_from_pink.toFixed(1)})`);
            console.log(`ðŸŸ¢ Green dot CORRECTED at X=${correctedGreenDotX} (center=${cyanCenterX} + offset=${horizontalOffset_from_purple.toFixed(1)})`);
        }

        function updateAngleDisplays(elements, positions, config, dimensions) {
            const { cyanCenterX, basePointY, dotmargin } = config;
            const { correctedRedDotX, correctedGreenDotX, pinkDotX, pinkDotY_actual, purpleDotX, purpleDotY_actual } = positions;
            const { finalWidth, finalHeight } = dimensions;

            // Check if final exists - same logic as other functions
            const finalTextContent = elements.finalBox ? elements.finalBox.textContent.trim() : '';
            const hasNoFinal = !elements.finalBox || finalTextContent === '' || finalTextContent === 'âˆ…' || finalTextContent === 'â€”';

            // Calculate actual green dot Y position (conditional)
            const actualGreenDotY = hasNoFinal ?
                basePointY - (config.triangle_h + (finalHeight / 2)) :  // DEBUG: Lift if no final
                basePointY;  // Normal position if final exists

            // Left angle display
            if (elements.angleText) {
                const vectorToGreen = { x: correctedGreenDotX - correctedRedDotX, y: 0 };
                const vectorToPink = { x: pinkDotX - correctedRedDotX, y: pinkDotY_actual - basePointY };

                const dotProduct = vectorToGreen.x * vectorToPink.x + vectorToGreen.y * vectorToPink.y;
                const magnitudeGreen = Math.sqrt(vectorToGreen.x * vectorToGreen.x + vectorToGreen.y * vectorToGreen.y);
                const magnitudePink = Math.sqrt(vectorToPink.x * vectorToPink.x + vectorToPink.y * vectorToPink.y);
                const angleRadians = Math.acos(dotProduct / (magnitudeGreen * magnitudePink));
                const angleDegrees = angleRadians * (180 / Math.PI);

                const redMidX = (cyanCenterX + correctedRedDotX) / 2;
                elements.angleText.style.left = (redMidX - 15) + 'px';
                elements.angleText.style.top = (basePointY + 25 + dotmargin) + 'px';
                elements.angleText.textContent = `${Math.round(angleDegrees)}Â°`;
            }

            // Right angle display (using actual green dot position)
            if (elements.angleTextGreen) {
                const vectorToRed_green = { x: correctedRedDotX - correctedGreenDotX, y: 0 };
                const vectorToPurple_green = { x: purpleDotX - correctedGreenDotX, y: purpleDotY_actual - actualGreenDotY }; // Use conditional green dot Y

                const dotProduct_green = vectorToRed_green.x * vectorToPurple_green.x + vectorToRed_green.y * vectorToPurple_green.y;
                const magnitudeRed_green = Math.sqrt(vectorToRed_green.x * vectorToRed_green.x + vectorToRed_green.y * vectorToRed_green.y);
                const magnitudePurple_green = Math.sqrt(vectorToPurple_green.x * vectorToPurple_green.x + vectorToPurple_green.y * vectorToPurple_green.y);
                const angleRadians_green = Math.acos(dotProduct_green / (magnitudeRed_green * magnitudePurple_green));
                const angleDegrees_green = angleRadians_green * (180 / Math.PI);

                const greenMidX = (cyanCenterX + correctedGreenDotX) / 2;
                elements.angleTextGreen.style.left = (greenMidX - 15) + 'px';
                elements.angleTextGreen.style.top = (actualGreenDotY + 25 + dotmargin) + 'px'; // Use conditional green dot Y for positioning
                elements.angleTextGreen.textContent = `${Math.round(angleDegrees_green)}Â°`;
            }
        }

        function updateLayoutDependentElements(elements, positions, dimensions, config) {
            setTimeout(() => {
                // Only update debug borders - labels are now positioned in main flow
                updateDebugBorders(elements, positions, dimensions, config);
            }, 10);
        }

        function updateDebugBorders(elements, positions, dimensions, config) {
            const containerRect = elements.container.getBoundingClientRect();

            // Foundation border
            const foundationCharRect = elements.foundationBox.getBoundingClientRect();
            elements.foundationBorder.style.left = (foundationCharRect.left - containerRect.left) + 'px';
            elements.foundationBorder.style.top = (foundationCharRect.top - containerRect.top) + 'px';
            elements.foundationBorder.style.width = foundationCharRect.width + 'px';
            elements.foundationBorder.style.height = foundationCharRect.height + 'px';
            elements.foundationDimensions.textContent = Math.round(foundationCharRect.width) + 'x' + Math.round(foundationCharRect.height);
            elements.foundationDimensions.style.left = (foundationCharRect.left - containerRect.left) + 'px';
            const foundationDimensionsLabelHeight = elements.foundationDimensions.offsetHeight || 12;
            elements.foundationDimensions.style.top = (foundationCharRect.top - containerRect.top - foundationDimensionsLabelHeight) + 'px';

            // Vowel border
            const vowelCharRect = elements.vowelBox.querySelector('.component-char').getBoundingClientRect();
            elements.vowelBorder.style.left = (vowelCharRect.left - containerRect.left) + 'px';
            elements.vowelBorder.style.top = (vowelCharRect.top - containerRect.top) + 'px';
            elements.vowelBorder.style.width = vowelCharRect.width + 'px';
            elements.vowelBorder.style.height = vowelCharRect.height + 'px';
            elements.vowelDimensions.textContent = Math.round(vowelCharRect.width) + 'x' + Math.round(vowelCharRect.height);
            elements.vowelDimensions.style.left = (vowelCharRect.left - containerRect.left) + 'px';
            const dimensionsLabelHeight = elements.vowelDimensions.offsetHeight || 12;
            elements.vowelDimensions.style.top = (vowelCharRect.top - containerRect.top - dimensionsLabelHeight) + 'px';

            // Final border
            if (elements.finalBox) {
                const finalCharRect = elements.finalBox.getBoundingClientRect();
                elements.finalBorder.style.left = (finalCharRect.left - containerRect.left) + 'px';
                elements.finalBorder.style.top = (finalCharRect.top - containerRect.top) + 'px';
                elements.finalBorder.style.width = finalCharRect.width + 'px';
                elements.finalBorder.style.height = finalCharRect.height + 'px';
                elements.finalDimensions.textContent = Math.round(finalCharRect.width) + 'x' + Math.round(finalCharRect.height);
                elements.finalDimensions.style.left = (finalCharRect.left - containerRect.left) + 'px';
                const finalDimensionsLabelHeight = elements.finalDimensions.offsetHeight || 12;
                elements.finalDimensions.style.top = (finalCharRect.top - containerRect.top - finalDimensionsLabelHeight) + 'px';
            }

            // Closed indicator border
            if (elements.closedIndicator && elements.closedBorder) {
                const closedRect = elements.closedIndicator.getBoundingClientRect();
                elements.closedBorder.style.left = (closedRect.left - containerRect.left) + 'px';
                elements.closedBorder.style.top = (closedRect.top - containerRect.top) + 'px';
                elements.closedBorder.style.width = closedRect.width + 'px';
                elements.closedBorder.style.height = closedRect.height + 'px';
            }
        }

        function renderReadingOrder(syllable) {
            let components = [];

            // Foundation
            if (syllable.foundation) {
                let foundationStr;

                if (typeof syllable.foundation === 'object' && syllable.foundation.consonants) {
                    // Foundation is an object with consonants and possibly tone
                    foundationStr = syllable.foundation.consonants.join('');

                    // Add tone mark if present
                    if (syllable.foundation.tone) {
                        // Insert tone mark after the tone_owner consonant
                        const toneOwner = syllable.foundation.tone_owner || 0;
                        const consonants = syllable.foundation.consonants;

                        if (toneOwner < consonants.length) {
                            // Build string with tone mark placed correctly
                            let result = '';
                            for (let i = 0; i < consonants.length; i++) {
                                result += consonants[i];
                                if (i === toneOwner) {
                                    result += syllable.foundation.tone;
                                }
                            }
                            foundationStr = result;
                        } else {
                            // Fallback: append tone mark at end
                            foundationStr += syllable.foundation.tone;
                        }
                    }
                } else if (Array.isArray(syllable.foundation)) {
                    foundationStr = syllable.foundation.join('');
                } else {
                    foundationStr = syllable.foundation;
                }

                // Check if foundation is a cluster
                let foundationChars = [];
                if (typeof syllable.foundation === 'object' && syllable.foundation.consonants) {
                    foundationChars = syllable.foundation.consonants;
                } else if (Array.isArray(syllable.foundation)) {
                    foundationChars = syllable.foundation;
                } else {
                    foundationChars = [syllable.foundation];
                }
                const isCluster = foundationChars.length > 1;
                const clusterNote = isCluster ? '<div style="font-size: 12px; color: var(--panel-text); margin-top: 4px;">(cluster)</div>' : '';

                components.push(`
                    <div class="reading-component">
                        <div class="component-char">${foundationStr}</div>
                    </div>
                `);
            }

            // Vowel - show pattern with English letters (x, f) using correct font
            components.push(`
                <div class="reading-component">
                    <div class="component-char" style="font-family: 'Microsoft Sans Serif' !important;">${syllable.pattern || ''}</div>
                </div>
            `);

            // Final (if present)
            if (syllable.final) {
                let finalStr;

                if (typeof syllable.final === 'object' && syllable.final.consonants) {
                    // Final is an object with consonants and possibly tone
                    finalStr = syllable.final.consonants.join('');

                    // Add tone mark if present
                    if (syllable.final.tone) {
                        // Insert tone mark after the tone_owner consonant
                        const toneOwner = syllable.final.tone_owner || 0;
                        const consonants = syllable.final.consonants;

                        if (toneOwner < consonants.length) {
                            // Build string with tone mark placed correctly
                            let result = '';
                            for (let i = 0; i < consonants.length; i++) {
                                result += consonants[i];
                                if (i === toneOwner) {
                                    result += syllable.final.tone;
                                }
                            }
                            finalStr = result;
                        } else {
                            // Fallback: append tone mark at end
                            finalStr += syllable.final.tone;
                        }
                    }
                } else if (Array.isArray(syllable.final)) {
                    finalStr = syllable.final.join('');
                } else {
                    finalStr = syllable.final;
                }

                components.push(`
                    <div class="reading-component">
                        <div class="component-char">${finalStr}</div>
                    </div>
                `);
            }

            // Triangular layout with dynamic spacing for 30-degree angles
            const containerId = `container-${Math.random().toString(36).substr(2, 9)}`;

            // No tan container wrapper - elements go directly into cyan container
            let html = '';

            // VOWEL TEXT RESTORED - positioned at blue triangle dot
            // NOTE: Vowel component uses Microsoft Sans Serif font for tone mark support
            if (components.length > 1) {
                html += '<div id="vowel-' + containerId + '" style="position: absolute;">';
                html += components[1].replace('<div class="component-char"', '<div class="component-char"');
                html += '</div>';
            }

            // Bottom row: Foundation and Final - positions will be calculated dynamically
            // NO HARDCODED POSITIONS - let positionDotsForContainer handle all positioning

            // Foundation: positioned dynamically
            if (components.length > 0) {
                html += `<div id="foundation-wrapper-${containerId}" style="position: absolute;">`;
                html += components[0].replace('<div class="component-char"', `<div id="foundation-${containerId}" class="component-char"`);
                html += '</div>';
            }

            // Check if there's no final consonant (needed for multiple sections)
            const hasNoFinal = !syllable.final || (Array.isArray(syllable.final) && syllable.final.length === 0);
            console.log('Has no final?', hasNoFinal);

            // Final: positioned dynamically (with opacity control for open syllables)
            const finalOpacity = hasNoFinal ? 'opacity: 0;' : '';
            html += `<div id="final-wrapper-${containerId}" style="position: absolute; ${finalOpacity}">`;
            if (components.length > 2) {
                html += components[2].replace('<div class="component-char"', `<div id="final-${containerId}" class="component-char"`);
            } else {
                // Empty final placeholder
                html += `<div id="final-${containerId}" class="reading-component"><div class="component-char" style="opacity: 0.3; font-size: 24px; color: #ccc;">â€”</div></div>`;
            }
            html += '</div>';

            // Field Name Labels - positioned dynamically
            // Check if foundation is a cluster
            console.log('Foundation data:', syllable.foundation);
            const isFoundationCluster = syllable.foundation &&
                                       Array.isArray(syllable.foundation) &&
                                       syllable.foundation.length > 1;
            console.log('Is foundation cluster?', isFoundationCluster);
            const foundationLabelText = isFoundationCluster ? 'Foundation<br>(cluster)' : 'Foundation';

            // Check if final is a cluster
            console.log('Final data:', syllable.final);
            const isFinalCluster = syllable.final &&
                                  Array.isArray(syllable.final) &&
                                  syllable.final.length > 1;
            console.log('Is final cluster?', isFinalCluster);
            const finalLabelText = isFinalCluster ? 'Final<br>(cluster)' : 'Final';

            // Set opacity for final label based on whether final exists
            const finalLabelOpacity = hasNoFinal ? 'opacity: 0;' : '';

            html += `<div id="foundation-label-${containerId}" style="position: absolute; font-size: var(--label-font-size, 12px); font-weight: bold; color: var(--syllable-label-text); background: var(--syllable-label-bg); padding: 1px 3px; border-radius: 2px; z-index: 98; pointer-events: none; text-align: center;">${foundationLabelText}</div>`;
            html += `<div id="vowel-label-${containerId}" style="position: absolute; font-size: var(--label-font-size, 12px); font-weight: bold; color: var(--syllable-label-text); background: var(--syllable-label-bg); padding: 1px 3px; border-radius: 2px; z-index: 98; pointer-events: none;">Vowel</div>`;
            html += `<div id="final-label-${containerId}" style="position: absolute; font-size: var(--label-font-size, 12px); font-weight: bold; color: var(--syllable-label-text); background: var(--syllable-label-bg); padding: 1px 3px; border-radius: 2px; z-index: 98; pointer-events: none; text-align: center; ${finalLabelOpacity}">${finalLabelText}</div>`;

            // Syllable type indicator - shows "Closed" or "Open" based on final consonant presence
            const syllableType = hasNoFinal ? 'Open' : 'Closed';
            html += `<div id="closed-indicator-${containerId}" style="position: absolute; z-index: 98; pointer-events: none; display: flex; align-items: center; gap: 4px;">`;
            // Show hollow circle for open, filled square for closed - sized relative to font
            if (hasNoFinal) {
                // Open syllable: hollow circle (sized relative to font)
                html += `<div style="width: calc(var(--label-font-size, 12px) * 0.8); height: calc(var(--label-font-size, 12px) * 0.8); background: var(--syllable-indicator-open-bg); border: 2px solid var(--syllable-indicator-open-color); border-radius: 50%;"></div>`;
            } else {
                // Closed syllable: filled square (sized relative to font)
                html += `<div style="width: calc(var(--label-font-size, 12px) * 0.8); height: calc(var(--label-font-size, 12px) * 0.8); background: var(--syllable-indicator-closed-bg); border: 1px solid var(--debug-dot-border);"></div>`;
            }
            html += `<span style="font-size: var(--label-font-size, 12px); font-weight: bold; color: ${hasNoFinal ? 'var(--syllable-indicator-open-color)' : 'var(--syllable-indicator-closed-color)'};">${syllableType}</span>`;
            html += `</div>`;

            // OLD DOT SYSTEM - COMMENTED OUT FOR REFERENCE
            /*
            // Red dots for testing coordinates - positioned within the container
            html += '<div id="dot1-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: red; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="dot2-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: red; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Blue dots for the other angle measurements
            html += '<div id="dot3-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: blue; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="dot4-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: blue; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Black center reference dots
            html += '<div id="center-dot-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: black; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="center-dot-top-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: black; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="center-dot-middle-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: gold; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="center-dot-left-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: green; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="center-dot-right-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: green; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            */

            // Distance display elements
            html += '<div id="left-distance-' + containerId + '" style="position: absolute; color: var(--debug-color-red); font-size: 12px; font-weight: bold; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="right-distance-' + containerId + '" style="position: absolute; color: var(--debug-color-blue); font-size: 12px; font-weight: bold; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="vertical-distance-' + containerId + '" style="position: absolute; color: var(--debug-color-dark); font-size: 12px; font-weight: bold; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="horizontal-left-distance-' + containerId + '" style="position: absolute; color: var(--debug-color-green); font-size: 12px; font-weight: bold; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="horizontal-right-distance-' + containerId + '" style="position: absolute; color: var(--debug-color-green); font-size: 12px; font-weight: bold; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Text box border elements
            html += '<div id="foundation-border-' + containerId + '" style="position: absolute; border: 2px solid var(--debug-color-red); z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="vowel-border-' + containerId + '" style="position: absolute; border: 2px solid var(--debug-color-blue); z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="final-border-' + containerId + '" style="position: absolute; border: 2px solid var(--debug-color-green); z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="closed-border-' + containerId + '" style="position: absolute; border: 2px solid var(--debug-color-orange); z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Text box dimension labels
            html += '<div id="foundation-dimensions-' + containerId + '" style="position: absolute; color: var(--debug-color-red); font-size: 10px; font-weight: bold; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none; background: var(--syllable-label-bg); padding: 1px 2px;"></div>';
            html += '<div id="vowel-dimensions-' + containerId + '" style="position: absolute; color: var(--debug-color-blue); font-size: 10px; font-weight: bold; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none; background: var(--syllable-label-bg); padding: 1px 2px;"></div>';
            html += '<div id="final-dimensions-' + containerId + '" style="position: absolute; color: var(--debug-color-green); font-size: 10px; font-weight: bold; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none; background: var(--syllable-label-bg); padding: 1px 2px;"></div>';

            // NEW DOT SYSTEM - Gold center dot (ABSOLUTE - never moves, cyan container center)
            html += '<div id="center-dot-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: gold; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Black base point dot - ABSOLUTE reference point 50px below gold dot (most important triangle point)
            html += '<div id="base-point-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: black; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Blue vowel point - positioned triangle_h above base point (same horizontal position)
            html += '<div id="point-vowel-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: blue; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Dynamic vowel-based dots - positioned relative to blue dot based on vowel dimensions
            html += '<div id="point-vowel-purple-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: purple; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="point-vowel-pink-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: pink; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Triangle base points f1 and f2 - same height as base point, positioned for 30Â° base angles (120Â° top angle)
            html += '<div id="point-f1-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: red; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';
            html += '<div id="point-f2-' + containerId + '" style="position: absolute; width: 8px; height: 8px; background: green; border-radius: 50%; z-index: 100; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // Line connecting red and green dots
            html += '<div id="red-green-line-' + containerId + '" style="position: absolute; height: 2px; background: #333; z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none;"></div>';

            // SVG Arrow from red dot to pink dot
            html += '<svg id="red-pink-arrow-' + containerId + '" style="position: absolute; z-index: 99; opacity: 1; pointer-events: none; overflow: visible;">';
            html += '<defs><marker id="arrowhead-' + containerId + '" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon id="arrowhead-polygon-' + containerId + '" points="0 0, 8 3, 0 6" fill="var(--arrow-color-red, #000000)" /></marker></defs>';
            html += '<line id="arrow-line-' + containerId + '" x1="0" y1="0" x2="100" y2="0" stroke="var(--arrow-color-red, #000000)" stroke-width="var(--arrow-stroke-width, 2)" marker-end="url(#arrowhead-' + containerId + ')" />';
            html += '</svg>';

            // SVG Arrow from blue dot to green dot
            // Check if there's no final consonant to make arrow dotted (variable already declared above)
            const arrowDashArray = hasNoFinal ? 'stroke-dasharray="3,3"' : '';

            html += '<svg id="purple-green-arrow-' + containerId + '" style="position: absolute; z-index: 99; opacity: 1; pointer-events: none; overflow: visible;">';
            html += '<defs><marker id="arrowhead-purple-' + containerId + '" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon id="arrowhead-polygon-purple-' + containerId + '" points="0 0, 8 3, 0 6" fill="var(--arrow-color-blue, #000000)" /></marker></defs>';
            html += `<line id="arrow-line-purple-${containerId}" x1="0" y1="0" x2="100" y2="0" stroke="var(--arrow-color-blue, #000000)" stroke-width="var(--arrow-stroke-width, 2)" ${arrowDashArray} marker-end="url(#arrowhead-purple-${containerId})" />`;
            html += '</svg>';

            html += '<div id="angle-text-' + containerId + '" style="position: absolute; z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none; font-size: 14px; font-weight: bold; color: var(--debug-color-purple); background: var(--syllable-label-bg); padding: 2px 4px; border-radius: 3px;"></div>';

            // Simple angle text for green vertex (red-green-purple angle)
            html += '<div id="angle-text-green-' + containerId + '" style="position: absolute; z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none; font-size: 14px; font-weight: bold; color: var(--debug-color-red); background: var(--syllable-label-bg); padding: 2px 4px; border-radius: 3px;"></div>';

            // Debug distance label between black and red dots
            html += '<div id="distance-label-' + containerId + '" style="position: absolute; z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none; font-size: 12px; font-weight: bold; color: var(--debug-color-orange); background: var(--syllable-label-bg); padding: 2px 4px; border-radius: 3px; border: 1px solid var(--debug-color-orange);"></div>';

            // Debug distance label between green and black dots
            html += '<div id="green-distance-label-' + containerId + '" style="position: absolute; z-index: 99; opacity: var(--debug-dots-opacity); pointer-events: none; font-size: 12px; font-weight: bold; color: var(--debug-color-green); background: var(--syllable-label-bg); padding: 2px 4px; border-radius: 3px; border: 1px solid var(--debug-color-green);"></div>';


            // Add to positioning queue - calculate dynamic positions for 30-degree angles
            setTimeout(() => calculateDynamicPositions(containerId), 50);

            return html;
        }

        async function loadTagsForInterpretation(syllable, index) {
            try {
                const response = await fetch('http://localhost:5001/api/get-tags', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        characters: {
                            foundation: syllable.foundation,
                            vowel: syllable.vowel,
                            final: syllable.final
                        }
                    })
                });

                const tags = await response.json();
                const tagsContainer = document.getElementById(`tags-${index}`);

                let tagsHtml = '';
                for (const [type, data] of Object.entries(tags)) {
                    if (data.tags && data.tags.length > 0) {
                        tagsHtml += `<div style="margin-top: 5px;">`;
                        tagsHtml += `<strong style="font-size: 11px; color: var(--panel-text);">${type}:</strong> `;
                        data.tags.forEach(tag => {
                            tagsHtml += `<span class="tag">${tag}</span>`;
                        });
                        tagsHtml += `</div>`;
                    }
                }

                tagsContainer.innerHTML = tagsHtml || '<small style="color: #999;">No tags found</small>';

            } catch (error) {
                console.error('Error loading tags:', error);
            }
        }

        // REMOVED: Old selection function - replaced with validation tracking
        // function selectInterpretation(index) { ... }

        // NEW: Track validation status changes
        function onValidityChange(index) {
            const dropdown = document.getElementById(`validity-${index}`);
            const status = dropdown.value;

            // Show/hide relevant sections based on status
            const invalidComponents = document.getElementById(`invalid-components-${index}`);
            const synonymousSelector = document.getElementById(`synonymous-${index}`);

            if (status === 'invalid') {
                invalidComponents.style.display = 'block';
                synonymousSelector.style.display = 'none';
            } else if (status === 'synonymous') {
                invalidComponents.style.display = 'none';
                synonymousSelector.style.display = 'block';
            } else {
                invalidComponents.style.display = 'none';
                synonymousSelector.style.display = 'none';
            }

            updateValidationProgress();
        }

        // NEW: Update progress counter
        function updateValidationProgress() {
            const dropdowns = document.querySelectorAll('.validity-dropdown');
            let labeled = 0;

            dropdowns.forEach(dropdown => {
                if (dropdown.value !== 'unlabeled') {
                    labeled++;
                }
            });

            const progressSpan = document.getElementById('validationProgress');
            if (progressSpan) {
                progressSpan.textContent = `${labeled}/${dropdowns.length}`;
            }
        }

        // NEW: Collect all validation data for saving
        function collectValidationData() {
            const validations = [];

            currentInterpretations.forEach((interp, index) => {
                const dropdown = document.getElementById(`validity-${index}`);
                const status = dropdown.value;

                if (status === 'unlabeled') {
                    return; // Skip unlabeled interpretations
                }

                const validation = {
                    interpretation_id: interp.db_id,
                    validity_status: status
                };

                if (status === 'invalid') {
                    // Collect invalid components
                    const checkboxes = document.querySelectorAll(`#invalid-components-${index} input[type="checkbox"]:checked`);
                    const reason = document.getElementById(`invalid-reason-${index}`).value;

                    validation.invalid_components = Array.from(checkboxes).map(cb => ({
                        type: cb.value,
                        value: cb.dataset.value,
                        reason: reason || 'marked_invalid_by_user'
                    }));
                } else if (status === 'synonymous') {
                    const synonymousWith = document.getElementById(`synonymous-with-${index}`).value;
                    if (synonymousWith) {
                        validation.synonymous_with_id = parseInt(synonymousWith);
                    }
                }

                validations.push(validation);
            });

            return validations;
        }

        // MODIFIED: Save batch validation labels instead of single selection
        async function saveLabel() {
            const validations = collectValidationData();

            if (validations.length === 0) {
                alert('Please label at least one interpretation before saving');
                return;
            }

            const labelData = {
                word_id: currentWordId,
                session_id: sessionId,
                labeler: 'user',
                validations: validations
            };

            try {
                // Use new batch validation endpoint
                const response = await fetch('http://localhost:5001/api/save-interpretation-validations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(labelData)
                });

                const result = await response.json();
                if (result.success) {
                    stats.labels += validations.length;
                    stats.words.add(currentWord);
                    updateStats();

                    showSuccessModal(false, `Saved ${result.validations_saved} validations`);

                    // Mark queue item as labeled
                    if (currentQueueIndex >= 0) {
                        wordQueue[currentQueueIndex].labeled = true;
                        updateWordQueue();
                        nextInQueue();
                    } else {
                        // Clear for next word
                        document.getElementById('wordInput').value = '';
                        document.getElementById('analysisSection').style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Error saving validations:', error);
                alert('Error saving validations');
            }
        }

        function skipWord() {
            if (currentQueueIndex >= 0) {
                nextInQueue();
            } else {
                document.getElementById('wordInput').value = '';
                document.getElementById('analysisSection').style.display = 'none';
            }
        }

        function loadBatch() {
            const input = document.getElementById('batchInput').value.trim();
            if (!input) return;

            const words = input.split('\n').map(w => w.trim()).filter(w => w);
            wordQueue = words.map(word => ({ word, labeled: false }));
            currentQueueIndex = -1;

            updateWordQueue();
            document.getElementById('batchInput').value = '';

            if (wordQueue.length > 0) {
                nextInQueue();
            }
        }

        function updateWordQueue() {
            const container = document.getElementById('wordQueue');
            container.innerHTML = '';

            wordQueue.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                if (index === currentQueueIndex) div.classList.add('current');
                if (item.labeled) div.classList.add('labeled');

                div.innerHTML = `
                    <span class="queue-word">${item.word}</span>
                    <span class="queue-status">${item.labeled ? 'âœ“' : ''}</span>
                `;
                div.onclick = () => goToQueueItem(index);

                container.appendChild(div);
            });
        }

        function nextInQueue() {
            if (currentQueueIndex < wordQueue.length - 1) {
                currentQueueIndex++;
                const item = wordQueue[currentQueueIndex];
                document.getElementById('wordInput').value = item.word;
                analyzeWord(item.word);
                updateWordQueue();
            }
        }

        function goToQueueItem(index) {
            currentQueueIndex = index;
            const item = wordQueue[index];
            document.getElementById('wordInput').value = item.word;
            analyzeWord(item.word);
            updateWordQueue();
        }

        function updateStats() {
            document.getElementById('labelCount').textContent = stats.labels;
            document.getElementById('customCount').textContent = stats.custom;
            document.getElementById('wordCount').textContent = stats.words.size;
        }

        function showSuccessModal(isCustom) {
            const modal = document.getElementById('successModal');
            const message = document.getElementById('modalMessage');

            if (isCustom) {
                message.textContent = 'Custom interpretation saved! This helps identify gaps in the algorithm.';
            } else {
                message.textContent = 'Label saved successfully!';
            }

            modal.classList.add('show');
        }

        function closeModal() {
            document.getElementById('successModal').classList.remove('show');
        }

        // Server restart functionality
        async function restartServer() {
            if (!confirm('Are you sure you want to restart the server? This will reload the page and any unsaved work will be lost.')) {
                return;
            }

            // Save current word for restoration after restart
            const currentWordInput = document.getElementById('wordInput').value;
            if (currentWordInput.trim()) {
                sessionStorage.setItem('restartCurrentWord', currentWordInput.trim());
            }

            // Save debug mode state
            const debugMode = document.getElementById('debugToggle').checked;
            sessionStorage.setItem('restartDebugMode', debugMode.toString());

            try {
                // Get current port from window location
                const currentPort = window.location.port || '5001';

                const response = await fetch(`http://localhost:${currentPort}/api/restart-server`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (response.ok) {
                    // Create non-blocking notification
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #4CAF50;
                        color: white;
                        padding: 15px 20px;
                        border-radius: 8px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        z-index: 10000;
                        font-family: Arial, sans-serif;
                        font-size: 14px;
                    `;
                    notification.textContent = 'Server restarting... Page will reload in 1 second.';
                    document.body.appendChild(notification);

                    // Reload after delay
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                } else {
                    alert('Failed to restart server. Check console for details.');
                }
            } catch (error) {
                console.error('Error restarting server:', error);
                // If restart call fails, just reload the page as fallback
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #ff9800;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    z-index: 10000;
                    font-family: Arial, sans-serif;
                    font-size: 14px;
                `;
                notification.textContent = 'Restart request failed. Reloading page as fallback...';
                document.body.appendChild(notification);

                setTimeout(() => {
                    window.location.reload();
                }, 1000);
            }
        }

        // Theme and Font Controls
        let isDarkMode = localStorage.getItem('darkMode') === 'true';

        // Font settings (simple approach like pattern classifier)
        let currentFontFamily = 'thai-sarabun';
        let currentFontSize = 24;
        let currentFontWeight = 400;

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            localStorage.setItem('darkMode', isDarkMode);
            applyTheme();
        }

        function applyTheme() {
            const body = document.body;
            const toggle = document.querySelector('.theme-toggle');

            if (isDarkMode) {
                body.setAttribute('data-theme', 'dark');
                toggle.textContent = 'â˜€ï¸ Light Mode';
                // Set arrow colors for dark mode
                document.documentElement.style.setProperty('--arrow-color-red', '#ff1493');
                document.documentElement.style.setProperty('--arrow-color-blue', '#ff1493');
            } else {
                body.removeAttribute('data-theme');
                toggle.textContent = 'ðŸŒ™ Dark Mode';
                // Set arrow colors for light mode
                document.documentElement.style.setProperty('--arrow-color-red', '#000000');
                document.documentElement.style.setProperty('--arrow-color-blue', '#000000');
            }
        }

        function changeThaiFontFamily() {
            currentFontFamily = document.getElementById('fontSelect').value;
            applyFontSettings();
        }

        function changeFontSize() {
            currentFontSize = document.getElementById('fontSizeSlider').value;
            document.getElementById('fontSizeDisplay').textContent = currentFontSize + 'px';
            applyFontSettings();
        }

        function changeFontWeight() {
            currentFontWeight = document.getElementById('fontWeightSelect').value;
            applyFontSettings();
        }

        function toggleDebugMode() {
            const isDebug = document.getElementById('debugToggle').checked;
            const isDarkMode = document.body.hasAttribute('data-theme') && document.body.getAttribute('data-theme') === 'dark';

            if (isDebug) {
                // Enable debug colors
                document.documentElement.style.setProperty('--card-bg-debug', '#666666');
                // Always use cyan for debug mode (override theme)
                document.documentElement.style.setProperty('--syllable-display-bg-debug', 'cyan');
                // Show dots and measurements
                document.documentElement.style.setProperty('--debug-dots-opacity', '1');
                // Enable debug arrow colors
                document.documentElement.style.setProperty('--arrow-color-red', 'var(--debug-color-red)');
                document.documentElement.style.setProperty('--arrow-color-blue', 'var(--debug-color-blue)');
            } else {
                // Reset to normal colors
                document.documentElement.style.setProperty('--card-bg-debug', 'var(--card-bg-normal)');
                document.documentElement.style.setProperty('--syllable-display-bg-debug', 'transparent');
                // Reset forced styles
                document.querySelectorAll('.syllable-display').forEach(el => {
                    el.style.background = '';
                });
                // Hide dots and measurements
                document.documentElement.style.setProperty('--debug-dots-opacity', '0');
                // Use theme-appropriate arrows in normal mode
                const arrowColor = isDarkMode ? '#ff1493' : '#000000';
                document.documentElement.style.setProperty('--arrow-color-red', arrowColor);
                document.documentElement.style.setProperty('--arrow-color-blue', arrowColor);
            }
        }

        // Interpretation View Tweaks Functions
        function toggleTweaksPanel() {
            const panel = document.getElementById('tweaksPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function updateTriangleHeight() {
            const triangleHeightValue = document.getElementById('triangleHeightSlider').value;
            document.getElementById('triangleHeightDisplay').textContent = triangleHeightValue + 'px';
            document.documentElement.style.setProperty('--triangle-height', triangleHeightValue);

            // Trigger recalculation of all interpretations
            if (currentWord) {
                setTimeout(() => {
                    analyzeWord(currentWord);
                }, 50);
            }
        }

        function updateBaseAngle() {
            const baseAngleValue = document.getElementById('baseAngleSlider').value;
            document.getElementById('baseAngleDisplay').textContent = baseAngleValue + 'Â°';
            document.documentElement.style.setProperty('--base-angle', baseAngleValue);

            // Trigger recalculation of all interpretations
            if (currentWord) {
                setTimeout(() => {
                    analyzeWord(currentWord);
                }, 50);
            }
        }

        function updateArrowheadSize() {
            const arrowWidthValue = document.getElementById('arrowWidthSlider').value;
            const arrowHeightValue = document.getElementById('arrowHeightSlider').value;

            document.getElementById('arrowWidthDisplay').textContent = arrowWidthValue + 'px';
            document.getElementById('arrowHeightDisplay').textContent = arrowHeightValue + 'px';

            document.documentElement.style.setProperty('--arrowhead-width', arrowWidthValue);
            document.documentElement.style.setProperty('--arrowhead-height', arrowHeightValue);
            document.documentElement.style.setProperty('--arrowhead-refx', Math.round(arrowWidthValue * 0.875)); // 7/8 of width
            document.documentElement.style.setProperty('--arrowhead-refy', Math.round(arrowHeightValue / 2)); // half height

            // Update all existing SVG arrowheads immediately
            updateAllArrowheadAttributes(arrowWidthValue, arrowHeightValue);

            // Also trigger a re-analysis if we have a current word to ensure new elements get updated
            if (currentWord) {
                setTimeout(() => {
                    analyzeWord(currentWord);
                }, 100);
            }
        }

        function updateAllArrowheadAttributes(width, height) {
            const refX = Math.round(width * 0.875);
            const refY = Math.round(height / 2);
            const points = `0 0, ${width} ${refY}, 0 ${height}`;

            console.log(`Updating arrowheads: ${width}x${height}, refX=${refX}, refY=${refY}, points="${points}"`);

            // Find all arrowhead markers and polygons in the document
            const markers = document.querySelectorAll('[id^="arrowhead-"]');
            const polygons = document.querySelectorAll('[id^="arrowhead-polygon-"]');

            console.log(`Found ${markers.length} markers and ${polygons.length} polygons to update`);

            markers.forEach(marker => {
                if (marker.tagName === 'marker') {
                    marker.setAttribute('markerWidth', width);
                    marker.setAttribute('markerHeight', height);
                    marker.setAttribute('refX', refX);
                    marker.setAttribute('refY', refY);
                    console.log(`Updated marker: ${marker.id}`);
                }
            });

            polygons.forEach(polygon => {
                polygon.setAttribute('points', points);
                console.log(`Updated polygon: ${polygon.id}`);
            });
        }

        function updateArrowStroke() {
            const arrowStrokeValue = document.getElementById('arrowStrokeSlider').value;
            document.getElementById('arrowStrokeDisplay').textContent = arrowStrokeValue + 'px';
            document.documentElement.style.setProperty('--arrow-stroke-width', arrowStrokeValue);
        }

        function updateLabelFontSize() {
            const labelFontSizeValue = document.getElementById('labelFontSizeSlider').value;
            document.getElementById('labelFontSizeDisplay').textContent = labelFontSizeValue + 'px';
            document.documentElement.style.setProperty('--label-font-size', labelFontSizeValue + 'px');

            // Force immediate reflow to ensure label font changes are applied (same as applyFontSettings)
            document.body.offsetHeight;

            // Reposition all interpretations to account for label size changes
            recalculateTextDimensionsAndTriangles();
        }

        function resetTweaksToDefaults() {
            // Reset all sliders to default values
            document.getElementById('triangleHeightSlider').value = '40';
            document.getElementById('baseAngleSlider').value = '25';
            document.getElementById('arrowWidthSlider').value = '8';
            document.getElementById('arrowHeightSlider').value = '6';
            document.getElementById('arrowStrokeSlider').value = '2';
            document.getElementById('labelFontSizeSlider').value = '12';

            // Update displays and apply changes
            updateTriangleHeight();
            updateBaseAngle();
            updateArrowheadSize();
            updateArrowStroke();
            updateLabelFontSize();
        }

        function initializeTweaksDefaults() {
            // Initialize CSS variables with default values
            document.documentElement.style.setProperty('--triangle-height', '40');
            document.documentElement.style.setProperty('--base-angle', '25');
            document.documentElement.style.setProperty('--arrowhead-width', '8');
            document.documentElement.style.setProperty('--arrowhead-height', '6');
            document.documentElement.style.setProperty('--arrowhead-refx', '7');
            document.documentElement.style.setProperty('--arrowhead-refy', '3');
            document.documentElement.style.setProperty('--arrow-stroke-width', '2');
            document.documentElement.style.setProperty('--label-font-size', '12px');

            // Set initial arrow colors based on theme (normal mode)
            const isDarkMode = document.body.hasAttribute('data-theme') && document.body.getAttribute('data-theme') === 'dark';
            const arrowColor = isDarkMode ? '#ff1493' : '#000000';
            document.documentElement.style.setProperty('--arrow-color-red', arrowColor);
            document.documentElement.style.setProperty('--arrow-color-blue', arrowColor);

            // Wait a bit for DOM elements to be created, then update arrowheads
            setTimeout(() => {
                updateAllArrowheadAttributes(8, 6);
            }, 100);
        }

        function containsThaiCharacters(text) {
            // Check if text contains Thai characters (U+0E00-U+0E7F)
            return /[\u0E00-\u0E7F]/.test(text);
        }

        function convertTemplateToThai(template) {
            // Replace placeholders with actual Thai consonants for proper rendering
            // x = initial consonant (à¸), f = final consonant (à¸‡)
            // This ensures tone marks display properly since Thai fonts support tone marks on Thai consonants
            return template.replace(/x/g, 'à¸').replace(/f/g, 'à¸‡');
        }

        function addPatternDisplay(template) {
            // Show both English template and Thai version for clarity
            const thaiVersion = convertTemplateToThai(template);
            if (template !== thaiVersion && /[xf]/.test(template)) {
                return `${thaiVersion} (${template})`;
            }
            return template;
        }

        function applyFontSettings() {
            // Update CSS custom property for font size to ensure dynamic elements respond
            document.documentElement.style.setProperty('--font-size', currentFontSize + 'px');

            // Apply font settings to Thai text elements (pattern classifier approach)
            // Note: .pattern-display excluded to preserve Unicode combining character support
            const thaiElements = document.querySelectorAll('.thai-input, #currentWord, .component-char, .form-input, .queue-word');

            thaiElements.forEach(element => {
                // Remove existing thai-* classes
                element.className = element.className.replace(/thai-\w+/g, '');
                // Add the current font family class
                element.classList.add(currentFontFamily);
                // Apply font size and weight as inline styles
                element.style.fontSize = currentFontSize + 'px';
                element.style.fontWeight = currentFontWeight;
            });

            // Force immediate reflow to ensure font changes are applied
            document.body.offsetHeight;

            // Recalculate text dimensions and triangle positioning after font changes
            setTimeout(() => {
                recalculateTextDimensionsAndTriangles();
            }, 150); // Even longer delay to ensure font changes are fully applied and text is re-rendered
        }

        function recalculateTextDimensionsAndTriangles() {
            console.log('ðŸ”„ Recalculating text dimensions and triangles...');

            // Find all syllable containers and recalculate their positioning
            const syllableContainers = document.querySelectorAll('.syllable-display');
            console.log(`Found ${syllableContainers.length} syllable containers`);

            syllableContainers.forEach((container, index) => {
                const readingOrderDiv = container.querySelector('.reading-order');
                if (readingOrderDiv) {
                    // Force layout recalculation by accessing offsetHeight
                    readingOrderDiv.offsetHeight;

                    // Extract containerId from the reading-order div
                    const foundationElement = readingOrderDiv.querySelector('[id^="foundation-"]');
                    if (foundationElement) {
                        // Handle both old format (foundation-containerId) and new format (foundation-wrapper-containerId)
                        const idParts = foundationElement.id.split('-');
                        let containerId;
                        if (idParts.length === 2) {
                            // Old format: foundation-containerId
                            containerId = idParts[1];
                        } else if (idParts.length >= 3) {
                            // New format: foundation-wrapper-containerId or foundation-containerId-...
                            // Take everything after "foundation-wrapper-" or "foundation-"
                            const foundationPrefix = idParts[0]; // "foundation"
                            if (idParts[1] === 'wrapper') {
                                containerId = idParts.slice(2).join('-'); // everything after "foundation-wrapper-"
                            } else {
                                containerId = idParts.slice(1).join('-'); // everything after "foundation-"
                            }
                        } else {
                            containerId = foundationElement.id; // fallback
                        }
                        console.log(`ðŸ“ Recalculating container ${index + 1}: ${containerId}`);

                        // Force layout recalculation on text elements to ensure new dimensions are available
                        const textElements = readingOrderDiv.querySelectorAll('.component-char');
                        textElements.forEach(el => {
                            const width = el.offsetWidth;
                            console.log(`Text element width: ${width}px, font-size: ${getComputedStyle(el).fontSize}`);
                        });

                        // Recalculate positioning for this container
                        setTimeout(() => {
                            console.log(`âš¡ Triggering position recalculation for ${containerId}`);
                            calculateDynamicPositions(containerId);
                            positionDotsForContainer(containerId);
                        }, 10);
                    }
                }
            });
        }

        // Initialize theme and font settings on page load
        function initializeUI() {
            // Apply saved theme
            applyTheme();

            // Set font control values to current variables
            document.getElementById('fontSelect').value = currentFontFamily;
            document.getElementById('fontSizeSlider').value = currentFontSize;
            document.getElementById('fontSizeDisplay').textContent = currentFontSize + 'px';
            document.getElementById('fontWeightSelect').value = currentFontWeight;

            // Apply initial font settings
            applyFontSettings();

            // Restore word if coming from restart
            const restartWord = sessionStorage.getItem('restartCurrentWord');
            if (restartWord) {
                document.getElementById('wordInput').value = restartWord;
                sessionStorage.removeItem('restartCurrentWord'); // Clear after restoring
                // Auto-analyze the restored word
                setTimeout(() => analyzeWord(), 100);
            }

            // Restore debug mode state
            const restartDebugMode = sessionStorage.getItem('restartDebugMode');
            if (restartDebugMode !== null) {
                const isDebug = restartDebugMode === 'true';
                document.getElementById('debugToggle').checked = isDebug;
                sessionStorage.removeItem('restartDebugMode'); // Clear after restoring
                toggleDebugMode(); // Apply the debug mode
            }
        }

        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeTweaksDefaults();
            initSession();
            initializeUI();
            document.getElementById('wordInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') analyzeWord();
            });
        });
    </script>
</body>
</html>